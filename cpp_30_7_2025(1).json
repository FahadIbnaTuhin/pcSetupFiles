{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	"cp": {
	"prefix": "fit",
	"body": [
		"#include <bits/stdc++.h> ",
		"#include<ext/pb_ds/assoc_container.hpp>",
		"#include<ext/pb_ds/tree_policy.hpp>",
		"",
		"using namespace std;",
		"using namespace __gnu_pbds;",
		"",
		"typedef long long ll;",
		"typedef long double dl;",
		"template <typename T, typename P = null_type> using pbds = tree<T, P, less<T>, rb_tree_tag, tree_order_statistics_node_update>; // find_by_order, order_of_key",
		"",
		"#define endl '\\n'",
		"#define all(v) v.begin(), v.end()",
		"#define sz(x) (ll)x.size()",
		"#define mod 1000000007",
		"const ll inf = LLONG_MAX >> 1;",
		"const double pi = acos(-1.0);",
		"const double eps = 1e-9;",
		"",
		"void debug(const vector<ll> &v) {for(const ll &x: v) {cout << x << ' ';} cout << endl;}",
		"template<typename T>void o(const T& x, bool space = true) {cout << x;if (space) cout << endl;}",
		"template<typename F,typename S>ostream&operator<<(ostream&os,const pair<F,S>&p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}",
		"template<typename T>ostream&operator<<(ostream&os,const vector<T>&v){os<<\"{\";for(auto it=v.begin();it!=v.end();++it){if(it!=v.begin())os<<\", \";os<<*it;}return os<<\"}\";}",
		"template<typename T>ostream&operator<<(ostream&os,const set<T>&v){os<<\"[\";for(auto it=v.begin();it!=v.end();++it){if(it!=v.begin())os<<\",\";os<<*it;}return os<<\"]\";}",
		"template<typename T>ostream&operator<<(ostream&os,const multiset<T>&v) {os<<\"[\";for(auto it=v.begin();it!=v.end();++it){if(it!=v.begin())os<<\", \";os<<*it;}return os<<\"]\";}",
		"template<typename F,typename S>ostream&operator<<(ostream&os,const map<F,S>&v){os<<\"[\";for(auto it=v.begin();it!=v.end();++it){if(it!=v.begin())os<<\", \";os<<it->first<<\" = \"<<it->second;}return os<<\"]\";}",
		"template<typename T, typename C, typename Comp> ostream& operator<<(ostream& os, priority_queue<T, C, Comp> pq){os<<\"[\";while(!pq.empty()){os<<pq.top();pq.pop();if(!pq.empty())os<<\", \";}return os<<\"]\";}",
		"template<typename T, typename Compare> ostream& operator<<(ostream& os, const tree<T, null_type, Compare, rb_tree_tag, tree_order_statistics_node_update>& t) {os << \"[\";for (auto it = t.begin(); it != t.end(); ++it) {if (it != t.begin()) os << \", \";os << *it;}return os << \"]\";}",
		"#define dbg(args...) do {cerr << #args << \" : \"; faltu(args); } while(0)",
		"void faltu(){cerr << endl;}",
		"template<typename T>void faltu(T a[],ll n){for(ll i=0;i<n;++i)cerr<<a[i]<<' ';cerr<<endl;}",
		"template<typename T,typename...hello>void faltu(T arg,const hello&...rest){cerr<<arg<<' ';faltu(rest...);}",
		"",
		"inline void normal(ll &a) { a %= mod; (a < 0) && (a += mod); }",
		"inline ll modMul(ll a, ll b) { a %= mod, b %= mod; normal(a), normal(b); return (a*b)%mod; }",
		"inline ll modAdd(ll a, ll b) { a %= mod, b %= mod; normal(a), normal(b); return (a+b)%mod; }",
		"inline ll modSub(ll a, ll b) { a %= mod, b %= mod; normal(a), normal(b); a -= b; normal(a); return a; }",
		"inline ll modPow(ll b, ll p) { ll r = 1; while(p) { if(p&1) r = modMul(r, b); b = modMul(b, b); p >>= 1; } return r; }",
		"inline ll modInverse(ll a) { return modPow(a, mod-2); }",
		"inline ll modDiv(ll a, ll b) { return modMul(a, modInverse(b)); }",
		"// If you can't solve a problem with brute force, you likely don't understand it fully yet.",
		" ",
		"ll di[] = {0, 1, 0, -1};",
		"ll dj[] = {1, 0, -1, 0};",
		"string dir = \"RDLU\";",
		"",
		"",
		"",
		"void solve() {",
		"    $0",
		"}",
		"",
		"int main() {",
		"    ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);",
		"    ll t = 1;",
		"    cin >> t;",
		"    for (ll i = 1; i <= t; i++) {",
		"        // cout << \"Case #\" << i << \": \"; // cout << \"Case \" << i << \": \";",
		"        solve();",
		"    }",
		"",
		"",
		"",
		"",
		"    return 0;",
		"}"
	],
	"description": ""
	}, 
	"cp_advance_template": {
		"prefix": "fitAdv",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"typedef long long ll;",
			"typedef long double dl;",
			"typedef vector<int> vi;",
			"typedef vector<ll> vl;",
			"typedef vector<vi> vvi;",
			"typedef vector<vl> vvl;",
			"typedef pair<int, int> pii;",
			"typedef pair<double, double> pdd;",
			"typedef pair<ll, ll> pll;",
			"typedef vector<pii> vii;",
			"typedef vector<pll> vll;",
			"",
			"#define PB push_back",
			"#define F first",
			"#define S second",
			"#define MP make_pair",
			"#define endl '\\n'",
			"#define all(a) (a).begin(), (a).end()",
			"#define sz(x) (ll)x.size()",
			"#define mid(l, r) ((r + l) / 2)",
			"#define left(node) (node * 2)",
			"#define mx_int_prime 999999937",
			"",
			"const double PI = acos(-1);",
			"const double eps = 1e-9;",
			"const int inf = 2000000000;",
			"const ll infLL = 9000000000000000000;",
			"// #define mod 1000000007",
			"",
			"#define mem(a, b) memset(a, b, sizeof(a))",
			"#define gcd(a, b) __gcd(a, b)",
			"#define sqr(a) ((a) * (a))",
			"",
			"#define optimize() ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
			"#define fraction(a) cout.unsetf(ios::floatfield); cout.precision(a); cout.setf(ios::fixed, ios::floatfield);",
			"#define file() freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);",
			"",
			"typedef vector<int>::iterator vit;",
			"typedef set<int>::iterator sit;",
			"",
			"int dx[] = {0, 0, +1, -1};",
			"int dy[] = {+1, -1, 0, 0};",
			"",
			"// Debugger",
			"template <typename F, typename S>",
			"ostream& operator << (ostream& os, const pair<F, S>& p) {",
			"    return os << \"(\" << p.first << \", \" << p.second << \")\";",
			"}",
			"",
			"template <typename T>",
			"ostream &operator << (ostream &os, const vector<T>& v) {",
			"    os << \"{\";",
			"    for (auto it = v.begin(); it != v.end(); ++it) {",
			"        if (it != v.begin()) os << \", \";",
			"        os << *it;",
			"    }",
			"    return os << \"}\";",
			"}",
			"",
			"template <typename T>",
			"ostream &operator << (ostream &os, const set<T>& v) {",
			"    os << \"[\";",
			"    for (auto it = v.begin(); it != v.end(); ++it) {",
			"        if (it != v.begin()) os << \", \";",
			"        os << *it;",
			"    }",
			"    return os << \"]\";",
			"}",
			"",
			"template <typename T>",
			"ostream &operator << (ostream &os, const multiset<T>& v) {",
			"    os << \"[\";",
			"    for (auto it = v.begin(); it != v.end(); ++it) {",
			"        if (it != v.begin()) os << \", \";",
			"        os << *it;",
			"    }",
			"    return os << \"]\";",
			"}",
			"",
			"template <typename F, typename S>",
			"ostream &operator << (ostream &os, const map<F, S>& v) {",
			"    os << \"[\";",
			"    for (auto it = v.begin(); it != v.end(); ++it) {",
			"        if (it != v.begin()) os << \", \";",
			"        os << it->first << \" - \" << it->second;",
			"    }",
			"    return os << \"]\";",
			"}",
			"",
			"#define dbg(args...) do {cerr << #args << \" : \"; faltu(args); } while(0)",
			"",
			"void faltu() {",
			"    cerr << endl;",
			"}",
			"",
			"template <typename T>",
			"void faltu(T a[], int n) {",
			"    for (int i = 0; i < n; ++i) cerr << a[i] << ' ';",
			"    cerr << endl;",
			"}",
			"",
			"template <typename T, typename... hello>",
			"void faltu(T arg, const hello&... rest) {",
			"    cerr << arg << ' ';",
			"    faltu(rest...);",
			"}",
			"",
			"// Bitwise operations",
			"ll check_kth_bit(ll x, ll k) {  // return 1 if kth bit is on, otherwise 0",
			"    return (x & (1ULL << k)) != 0;",
			"}",
			"",
			"void print_on_bits(ll x) {",
			"    for (ll k = 0; k < 32; k++) {",
			"        if (check_kth_bit(x, k)) {",
			"            cout << k << ' '; // prints the position of the set bit",
			"        }",
			"    }",
			"    cout << '\\n';",
			"}",
			"",
			"ll count_on_bits(ll x) {",
			"    ll ans = 0;",
			"    for (ll k = 0; k < 32; k++) {",
			"        if (check_kth_bit(x, k)) {",
			"            ans++;",
			"        }",
			"    }",
			"    return ans;",
			"}",
			"",
			"void binaryRepresentation(ll x) {",
			"    for (ll i = 31; i >= 0; i--) {",
			"        cout << check_kth_bit(x, i);",
			"    }",
			"    cout << '\\n';",
			"}",
			"",
			"bool is_even(ll x) {",
			"    return (x & 1) == 0;",
			"}",
			"",
			"ll set_kth_bit(ll x, ll k) {",
			"    return x | (1 << k);",
			"}",
			"",
			"ll unset_kth_bit(ll x, ll k) {",
			"    return (x & (~(1 << k)));",
			"}",
			"",
			"ll toggle_kth_bit(ll x, ll k) {",
			"    return x ^ (1 << k);",
			"}",
			"",
			"bool check_power_of_2(ll x) {  // Better",
			"    return x > 0 && (x & (x - 1)) == 0;",
			"}",
			"",
			"// Modular arithmetic",
			"const ll mod = 1e9 + 7;",
			"",
			"ll modPow(ll x, ll y) {",
			"    int res = 1;",
			"    x = x % mod;",
			"    if (x == 0)",
			"        return 0;",
			"    while (y > 0) {",
			"        if (y & 1)",
			"            res = (res * x) % mod;",
			"        y = y >> 1;",
			"        x = (x * x) % mod;",
			"    }",
			"    return res;",
			"}",
			"",
			"ll add(ll a, ll b) {",
			"    return ((a % mod) + (b % mod)) % mod;",
			"}",
			"",
			"ll sub(ll a, ll b) {",
			"    return ((a % mod) - (b % mod) + mod) % mod;",
			"}",
			"",
			"ll mul(ll a, ll b) {",
			"    return ((a % mod) * (b % mod)) % mod;",
			"}",
			"",
			"ll modInverse(ll a) {",
			"    return modPow(a, mod - 2);",
			"}",
			"",
			"ll divi(ll a, ll b) {",
			"    return mul(a, modInverse(b));",
			"}",
			"",
			"void solve() {",
			"    $0",
			"}",
			"",
			"int main() {",
			"    // optimize();",
			"    ll t; cin >> t;",
			"    for (ll tc = 1; tc <= t; tc++) {",
			"        // cout << \"Case #\" << tc << \": \";",
			"        solve();",
			"    }",
			"    ",
			"    return 0;",
			"}"
		],
		"description": ""
	},
	"leetcode": {
		"prefix": "leet",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"typedef long long ll;",
			"typedef long double dl;",
			"",
			"#define endl '\\n'",
			"#define all(v) v.begin(), v.end()",
			"",
			"$0",
			"",
			"int main() {",
			"",
			"",
			"    // Solution st;",
			"    // cout << st.",
			"",
			"    return 0;",
			"}",
			""
		],
		"description": ""
	}, 
	"exponent": {
	"prefix": "exponent",
	"body": [
		"ll binPower(ll base, ll power) {",
		"    ll res = 1;",
		"    while (power > 0) {",
		"        if (power & 1) {",
		"            res = res * base;",
		"        }",
		"        base = base * base;",
		"        power >>= 1;",
		"    }",
		"    return res;",
		"}",
		"",
		"ll binPowerMod(ll base, ll power, ll m) {",
		"    ll res = 1;",
		"    base %= m;",
		"    while (power > 0) {",
		"        if (power & 1) {",
		"            res = res * base % m;",
		"        }",
		"        base = base * base % m;",
		"        power >>= 1;",
		"    }",
		"    return res;",
		"}",
		"",
		"ll binModInv(ll base, ll modd) {",
		"    return binPowerMod(base, modd - 2, modd);",
		"}"
	],
	"description": ""
	},
	"singleHash": {
	"prefix": "singleHash",
	"body": [
		"// --- Hashing Setup ---",
		"const ll P = 31;",
		"const ll HASH_MOD = 1e9 + 7;",
		"const ll MAX_LEN = 1e6 + 123;",
		"",
		"vector<ll> p_pow(MAX_LEN);       // Powers of P",
		"vector<ll> inv_p_pow(MAX_LEN);   // Modular inverses of powers of P",
		"",
		"// Fast modular exponentiation",
		"inline ll modPowH(ll b, ll p, ll m) { ll r = 1; while (p) { if (p & 1) r = (r * b) % m; b = (b * b) % m; p >>= 1;} return r; }",
		"inline ll modInverseH(ll a, ll m) {return modPowH(a, m - 2, m);}",
		"",
		"// Precompute powers and inverse powers",
		"void precomputeHash() {",
		"    p_pow[0] = 1;",
		"    for (ll i = 1; i < MAX_LEN; i++) {",
		"        p_pow[i] = (p_pow[i - 1] * P) % HASH_MOD;",
		"    }",
		"",
		"    inv_p_pow[MAX_LEN - 1] = modInverseH(p_pow[MAX_LEN - 1], HASH_MOD);",
		"    for (ll i = MAX_LEN - 2; i >= 0; i--) {",
		"        inv_p_pow[i] = (inv_p_pow[i + 1] * P) % HASH_MOD;",
		"    }",
		"}",
		"",
		"// Computes hash of full string",
		"ll compute_hash(const string& s) {",
		"    ll hash_value = 0;",
		"    for (ll i = 0; i < (ll)s.size(); i++) {",
		"        hash_value = (hash_value + (s[i] - 'a' + 1ll) * p_pow[i]) % HASH_MOD;",
		"    }",
		"    return hash_value;",
		"}",
		"",
		"// Prefix hashes: h[i] = hash of s[0..i-1]",
		"vector<ll> compute_prefix_hashes(const string& s) {",
		"    ll n = s.size();",
		"    vector<ll> h(n + 1, 0);",
		"    for (ll i = 0; i < n; i++) {",
		"        h[i + 1] = (h[i] + (s[i] - 'a' + 1) * p_pow[i]) % HASH_MOD;",
		"    }",
		"    return h;",
		"}",
		"",
		"// Get hash of s[l..r] (0-indexed) using precomputed prefix hashes",
		"ll get_substring_hash(const vector<ll>& h, ll l, ll r) {",
		"    ll raw_hash = (h[r + 1] - h[l] + HASH_MOD) % HASH_MOD;",
		"    return (raw_hash * inv_p_pow[l]) % HASH_MOD;",
		"}",
		"vector<vector<ll>> group_identical_strings(vector<string> const& s) { // O(nm + nlogn) [m = highest len of any string]",
		"    ll n = s.size();",
		"    vector<pair<ll, ll>> hashes(n);",
		"    for (ll i = 0; i < n; i++)",
		"        hashes[i] = {compute_hash(s[i]), i};",
		"",
		"    sort(hashes.begin(), hashes.end()); // O(nlogn)",
		"",
		"    vector<vector<ll>> groups;",
		"    for (ll i = 0; i < n; i++) { // O(n)",
		"        if (i == 0 || hashes[i].first != hashes[i-1].first)",
		"            groups.emplace_back();",
		"        groups.back().push_back(hashes[i].second);",
		"    }",
		"    return groups;",
		"} ",
		"ll count_unique_substrings(string const& s) { // TC: O(n^2)",
		"    ll n = s.size();",
		"",
		"    const ll p = 31;",
		"    const ll m = 1e9 + 9;",
		"    vector<ll> p_pow(n);",
		"    p_pow[0] = 1;",
		"    for (ll i = 1; i < n; i++)",
		"        p_pow[i] = (p_pow[i-1] * p) % m;",
		"",
		"    vector<ll> h(n + 1, 0);",
		"    for (ll i = 0; i < n; i++)",
		"        h[i+1] = (h[i] + (s[i] - 'a' + 1) * p_pow[i]) % m;",
		"",
		"    ll cnt = 0;",
		"    for (ll l = 1; l <= n; l++) {",
		"        unordered_set<ll> hs;",
		"        for (ll i = 0; i <= n - l; i++) {",
		"            ll cur_h = (h[i + l] + m - h[i]) % m;",
		"            cur_h = (cur_h * p_pow[n-i-1]) % m;",
		"            hs.insert(cur_h);",
		"        }",
		"        cnt += hs.size();",
		"    }",
		"    return cnt;",
		"} ",
		"vector<ll> rabin_karp(string const& pattern, string const& text) { // O(|s| + |t|)",
		"    const ll p = 31; ",
		"    const ll m = 1e9 + 9;",
		"    ll S = pattern.size(), T = text.size();",
		"",
		"    vector<ll> p_pow(max(S, T)); ",
		"    p_pow[0] = 1; ",
		"    for (ll i = 1; i < (int)p_pow.size(); i++) ",
		"        p_pow[i] = (p_pow[i-1] * p) % m;",
		"",
		"    vector<ll> h(T + 1, 0); ",
		"    for (ll i = 0; i < T; i++)",
		"        h[i+1] = (h[i] + (text[i] - 'a' + 1) * p_pow[i]) % m; ",
		"    ll h_s = 0; ",
		"    for (ll i = 0; i < S; i++) ",
		"        h_s = (h_s + (pattern[i] - 'a' + 1) * p_pow[i]) % m; ",
		"",
		"    vector<ll> occurrences;",
		"    for (ll i = 0; i + S - 1 < T; i++) {",
		"        ll cur_h = (h[i+S] + m - h[i]) % m;",
		"        if (cur_h == h_s * p_pow[i] % m)",
		"            occurrences.push_back(i);",
		"    }",
		"    return occurrences;",
		"}",
		"// ----------------------"
	],
	"description": ""
	},
	"doubleHash": {
	"prefix": "doubleHash",
	"body": [
		"// --- Hashing Setup ---",
		"const ll P1 = 31, P2 = 53;",
		"const ll MOD1 = 1e9 + 7, MOD2 = 1e9 + 9;",
		"const ll MAX_LEN = 1e6 + 123;",
		"",
		"vector<ll> p_pow1(MAX_LEN), p_pow2(MAX_LEN);",
		"vector<ll> inv_p_pow1(MAX_LEN), inv_p_pow2(MAX_LEN);",
		"",
		"inline ll modPowH(ll b, ll p, ll m) { ll r = 1; while (p) { if (p & 1) r = (r * b) % m; b = (b * b) % m; p >>= 1;} return r; }",
		"inline ll modInverseH(ll a, ll m) {return modPowH(a, m - 2, m);}",
		"",
		"void precomputeHash() {",
		"    p_pow1[0] = p_pow2[0] = 1;",
		"    for (ll i = 1; i < MAX_LEN; i++) {",
		"        p_pow1[i] = (p_pow1[i - 1] * P1) % MOD1;",
		"        p_pow2[i] = (p_pow2[i - 1] * P2) % MOD2;",
		"    }",
		"",
		"    inv_p_pow1[MAX_LEN - 1] = modInverseH(p_pow1[MAX_LEN - 1], MOD1);",
		"    inv_p_pow2[MAX_LEN - 1] = modInverseH(p_pow2[MAX_LEN - 1], MOD2);",
		"    for (ll i = MAX_LEN - 2; i >= 0; i--) {",
		"        inv_p_pow1[i] = (inv_p_pow1[i + 1] * P1) % MOD1;",
		"        inv_p_pow2[i] = (inv_p_pow2[i + 1] * P2) % MOD2;",
		"    }",
		"}",
		"pair<ll, ll> compute_hash(const string& s) {",
		"    ll h1 = 0, h2 = 0;",
		"    for (ll i = 0; i < (ll)s.size(); i++) {",
		"        ll val = s[i] - 'a' + 1;",
		"        h1 = (h1 + val * p_pow1[i]) % MOD1;",
		"        h2 = (h2 + val * p_pow2[i]) % MOD2;",
		"    }",
		"    return {h1, h2};",
		"}",
		"vector<pair<ll, ll>> compute_prefix_hashes(const string& s) {",
		"    ll n = s.size();",
		"    vector<pair<ll, ll>> h(n + 1, {0, 0});",
		"    for (ll i = 0; i < n; i++) {",
		"        ll val = s[i] - 'a' + 1;",
		"        h[i + 1].first  = (h[i].first + val * p_pow1[i]) % MOD1;",
		"        h[i + 1].second = (h[i].second + val * p_pow2[i]) % MOD2;",
		"    }",
		"    return h;",
		"}",
		"pair<ll, ll> get_substring_hash(const vector<pair<ll, ll>>& h, ll l, ll r) {",
		"    ll raw1 = (h[r + 1].first - h[l].first + MOD1) % MOD1;",
		"    ll raw2 = (h[r + 1].second - h[l].second + MOD2) % MOD2;",
		"    ll hash1 = (raw1 * inv_p_pow1[l]) % MOD1;",
		"    ll hash2 = (raw2 * inv_p_pow2[l]) % MOD2;",
		"    return {hash1, hash2};",
		"}",
		"vector<vector<ll>> group_identical_strings(const vector<string>& s) {",
		"    ll n = s.size();",
		"    vector<pair<pair<ll, ll>, ll>> hashes(n);",
		"    for (ll i = 0; i < n; i++)",
		"        hashes[i] = {compute_hash(s[i]), i};",
		"",
		"    sort(hashes.begin(), hashes.end());",
		"",
		"    vector<vector<ll>> groups;",
		"    for (ll i = 0; i < n; i++) {",
		"        if (i == 0 || hashes[i].first != hashes[i - 1].first)",
		"            groups.emplace_back();",
		"        groups.back().push_back(hashes[i].second);",
		"    }",
		"    return groups;",
		"}",
		"ll count_unique_substrings(const string& s) {",
		"    ll n = s.size();",
		"    set<pair<ll, ll>> seen;",
		"",
		"    for (ll i = 0; i < n; i++) {",
		"        ll h1 = 0, h2 = 0;",
		"        for (ll j = i; j < n; j++) {",
		"            ll val = s[j] - 'a' + 1;",
		"            h1 = (h1 * P1 + val) % MOD1;",
		"            h2 = (h2 * P2 + val) % MOD2;",
		"            seen.insert({h1, h2});",
		"        }",
		"    }",
		"    return seen.size();",
		"}",
		"vector<ll> rabin_karp(const string& pattern, const string& text) {",
		"    ll S = pattern.size(), T = text.size();",
		"",
		"    vector<ll> h1(T + 1, 0), h2(T + 1, 0);",
		"    for (ll i = 0; i < T; i++) {",
		"        h1[i + 1] = (h1[i] + (text[i] - 'a' + 1) * p_pow1[i]) % MOD1;",
		"        h2[i + 1] = (h2[i] + (text[i] - 'a' + 1) * p_pow2[i]) % MOD2;",
		"    }",
		"",
		"    ll hp1 = 0, hp2 = 0;",
		"    for (ll i = 0; i < S; i++) {",
		"        hp1 = (hp1 + (pattern[i] - 'a' + 1) * p_pow1[i]) % MOD1;",
		"        hp2 = (hp2 + (pattern[i] - 'a' + 1) * p_pow2[i]) % MOD2;",
		"    }",
		"",
		"    vector<ll> occurrences;",
		"    for (ll i = 0; i + S <= T; i++) {",
		"        ll cur1 = (h1[i + S] - h1[i] + MOD1) % MOD1;",
		"        ll cur2 = (h2[i + S] - h2[i] + MOD2) % MOD2;",
		"",
		"        ll h_sub1 = (cur1 * inv_p_pow1[i]) % MOD1;",
		"        ll h_sub2 = (cur2 * inv_p_pow2[i]) % MOD2;",
		"",
		"        if (h_sub1 == hp1 && h_sub2 == hp2)",
		"            occurrences.push_back(i);",
		"    }",
		"    return occurrences;",
		"}",
		"struct pair_hash { // for set, unordered_set",
		"    size_t operator()(const pair<ll, ll>& p) const {",
		"        auto h1 = hash<ll>{}(p.first);",
		"        auto h2 = hash<ll>{}(p.second);",
		"        return h1 ^ (h2 << 1);",
		"    }",
		"};",
		"// ----------------------"
	],
	"description": ""
	}
}